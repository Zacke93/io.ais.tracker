'use strict';

const EventEmitter = require('events');
const geometry = require('../utils/geometry');
const constants = require('../constants');
const GPSJumpAnalyzer = require('../utils/GPSJumpAnalyzer');

const { LINE_CROSSING_MIN_PROXIMITY_M } = constants;

/**
 * VesselDataService - Pure data management for vessels
 * Handles vessel storage, updates, and lifecycle without business logic
 */
class VesselDataService extends EventEmitter {
  constructor(logger, bridgeRegistry) {
    super();
    this.logger = logger;
    this.bridgeRegistry = bridgeRegistry;
    this.vessels = new Map(); // Map<mmsi, VesselData>
    this.bridgeVessels = new Map(); // Map<bridgeId, Set<mmsi>>
    this.cleanupTimers = new Map(); // Map<mmsi, timeoutId>
    this.gpsJumpAnalyzer = new GPSJumpAnalyzer(logger);
    
    // ENHANCED: Target bridge protection tracking
    this.targetBridgeProtection = new Map(); // Map<mmsi, ProtectionData>
    this.protectionTimers = new Map(); // Map<mmsi, timeoutId>
  }

  /**
   * Update or create a vessel
   * @param {string} mmsi - Vessel MMSI
   * @param {Object} data - AIS data
   * @returns {Object|null} Updated vessel object or null if filtered out
   */
  updateVessel(mmsi, data) {
    const oldVessel = this.vessels.get(mmsi);
    const isNewVessel = !oldVessel;

    // Create vessel data object
    const vessel = this._createVesselObject(mmsi, data, oldVessel);

    // Handle target bridge assignment and transitions
    if (isNewVessel && !vessel.targetBridge) {
      this.logger.debug(`üîç [TARGET_CHECK] ${mmsi}: Checking if new vessel should get target bridge (${vessel.sog}kn, ${vessel.cog}¬∞)`);
      if (this._shouldAssignTargetBridge(vessel)) {
        // New vessel: Calculate initial target bridge only if vessel appears to be moving
        vessel.targetBridge = this._calculateTargetBridge(vessel);
        if (vessel.targetBridge) {
          this.logger.debug(
            `üéØ [TARGET_BRIDGE_NEW] Assigned ${vessel.targetBridge} to new vessel ${mmsi} (${vessel.sog}kn)`,
          );
        }
      } else {
        this.logger.debug(`üö´ [TARGET_REJECTED] ${mmsi}: New vessel rejected for target bridge`);
      }
    } else if (!isNewVessel && vessel.targetBridge) {
      // ENHANCED: Check and apply target bridge protection before handling transitions
      const protectionActive = this._checkTargetBridgeProtection(vessel, oldVessel);
      
      // Existing vessel: Handle target bridge transitions and protection
      if (!protectionActive) {
        this._handleTargetBridgeTransition(vessel, oldVessel);

        // CRITICAL: Check if vessel has become anchored/stationary after having target bridge
        if (!this._shouldAssignTargetBridge(vessel)) {
          this.logger.debug(
            `üö´ [TARGET_REMOVAL] ${vessel.mmsi}: Removing target bridge ${vessel.targetBridge} - vessel appears to have anchored (${Number(vessel.sog)}kn)`,
          );
          vessel.targetBridge = null;
        }
      } else {
        this.logger.debug(
          `üõ°Ô∏è [TARGET_PROTECTION_ACTIVE] ${vessel.mmsi}: Target bridge protection preventing transitions`
        );
      }
    }

    // Store vessel
    this.vessels.set(mmsi, vessel);

    // Emit events
    if (isNewVessel) {
      this.emit('vessel:entered', { mmsi, vessel });
      this.logger.debug(`üÜï [VESSEL_DATA] New vessel entered: ${mmsi}`);
    } else {
      this.emit('vessel:updated', { mmsi, vessel, oldVessel });
      this.logger.debug(`üìù [VESSEL_DATA] Vessel updated: ${mmsi}`);
    }

    return vessel;
  }

  /**
   * Remove a vessel
   * @param {string} mmsi - Vessel MMSI
   * @param {string} reason - Reason for removal
   */
  removeVessel(mmsi, reason = 'timeout') {
    const vessel = this.vessels.get(mmsi);
    if (!vessel) {
      return;
    }

    // 300m Protection Zone: Check if vessel is within protection zone of any bridge
    if (reason === 'timeout') {
      const { PROTECTION_ZONE_RADIUS } = constants;

      // CRITICAL FIX: Check for stale/frozen GPS data before applying protection
      const lastMoveTime = vessel.lastPositionChange || vessel.timestamp || Date.now();
      const speed = vessel.sog || 0;
      // Different timeouts based on vessel movement
      const staleTimeout = speed < 0.5
        ? 15 * 60 * 1000 // 15 minutes for stationary vessels
        : 5 * 60 * 1000; // 5 minutes for moving vessels

      const timeSinceLastMove = Date.now() - lastMoveTime;

      if (timeSinceLastMove > staleTimeout) {
        this.logger.log(
          `üóëÔ∏è [STALE_DATA] Force removing vessel ${mmsi} - no movement for ${(timeSinceLastMove / 60000).toFixed(0)} minutes (speed: ${speed.toFixed(1)}kn)`,
        );
        // Continue with removal despite protection zone
      } else {
        // Only apply protection zone if vessel data is not stale
        for (const bridge of Object.values(this.bridgeRegistry.bridges)) {
          const distance = geometry.calculateDistance(
            vessel.lat,
            vessel.lon,
            bridge.lat,
            bridge.lon,
          );

          if (distance <= PROTECTION_ZONE_RADIUS) {
            this.logger.log(
              `‚ö†Ô∏è [PROTECTION_ZONE] Preventing removal of vessel ${mmsi} - within ${distance.toFixed(
                0,
              )}m of ${bridge.name} (reason: ${reason})`,
            );
            // Reschedule with longer timeout instead of removing
            this.scheduleCleanup(mmsi, 600000); // 10 minutes
            return;
          }
        }
      }
    }

    // Clear cleanup timer
    this._clearCleanupTimer(mmsi);

    // Remove from collections
    this.vessels.delete(mmsi);
    this._removeFromBridgeAssociations(mmsi);

    this.emit('vessel:removed', { mmsi, vessel, reason });
    this.logger.debug(`üóëÔ∏è [VESSEL_DATA] Vessel removed: ${mmsi} (${reason})`);
  }

  /**
   * Get vessel by MMSI
   * @param {string} mmsi - Vessel MMSI
   * @returns {Object|null} Vessel object or null
   */
  getVessel(mmsi) {
    return this.vessels.get(mmsi) || null;
  }

  /**
   * Get all vessels
   * @returns {Object[]} Array of all vessel objects
   */
  getAllVessels() {
    return Array.from(this.vessels.values());
  }

  /**
   * Get vessels by target bridge
   * @param {string} bridgeName - Target bridge name
   * @returns {Object[]} Array of vessels targeting this bridge
   */
  getVesselsByTargetBridge(bridgeName) {
    return Array.from(this.vessels.values()).filter(
      (vessel) => vessel.targetBridge === bridgeName,
    );
  }

  /**
   * Get vessels near a bridge
   * @param {string} bridgeId - Bridge ID
   * @returns {Object[]} Array of vessels near this bridge
   */
  getVesselsNearBridge(bridgeId) {
    const vesselSet = this.bridgeVessels.get(bridgeId);
    if (!vesselSet) {
      return [];
    }
    return Array.from(vesselSet)
      .map((mmsi) => this.vessels.get(mmsi))
      .filter(Boolean);
  }

  /**
   * Get vessels suitable for bridge text generation
   * @returns {Object[]} Array of relevant vessels
   */
  getVesselsForBridgeText() {
    const allVessels = Array.from(this.vessels.values());
    const filteredVessels = allVessels.map((vessel) => {
      // CRITICAL FIX: Special cases that should show in bridge text even without targetBridge
      const isUnderBridgeWithoutTarget = vessel.status === 'under-bridge' && !vessel.targetBridge;
      const isStallbackabraBridgeWaiting = vessel.status === 'stallbacka-waiting'; // NEW: Stallbackabron special status

      // BRIDGE TEXT V2.0 FIX: Waiting at target bridge without targetBridge assigned
      const isWaitingAtTargetBridge = vessel.status === 'waiting'
        && vessel.currentBridge
        && (vessel.currentBridge === 'Klaffbron' || vessel.currentBridge === 'Stridsbergsbron');

      // Must have target bridge (except special cases)
      if (!vessel.targetBridge && !isUnderBridgeWithoutTarget && !isStallbackabraBridgeWaiting && !isWaitingAtTargetBridge) {
        this.logger.debug(`‚ùå [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: No targetBridge and not special case`);
        return false;
      }

      // FIX: Don't mutate vessel in getter - return a modified copy instead
      // If waiting at target bridge without targetBridge, we'll handle it in BridgeTextService
      if (!vessel.targetBridge && isWaitingAtTargetBridge) {
        // Return a shallow copy with targetBridge set for presentation
        return {
          ...vessel,
          targetBridge: vessel.currentBridge,
          _derivedTargetBridge: true, // Mark as derived for debugging
        };
      }

      // Must be targeting a valid bridge (except under-bridge vessels without target)
      if (vessel.targetBridge && !this.bridgeRegistry.isValidTargetBridge(vessel.targetBridge)) {
        this.logger.debug(`‚ùå [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Invalid targetBridge: ${vessel.targetBridge}`);
        return false;
      }

      // Filter out likely anchored boats using same strict logic as target bridge assignment
      if (!this._isVesselSuitableForBridgeText(vessel)) {
        this.logger.debug(`‚ùå [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Not suitable for bridge text (anchored/slow)`);
        return false;
      }

      // Must have status that matters for bridge text
      // NOW INCLUDES: en-route with target bridge (for "p√• v√§g mot" messages)
      // AND: stallbacka-waiting for special Stallbackabron handling
      const relevantStatuses = [
        'approaching',
        'waiting',
        'stallbacka-waiting',
        'under-bridge',
        'passed',
        'en-route',
      ];

      const isRelevant = relevantStatuses.includes(vessel.status);
      if (!isRelevant) {
        this.logger.debug(`‚ùå [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Irrelevant status: ${vessel.status}`);
        return false;
      }

      this.logger.debug(`‚úÖ [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Included in bridge text (${vessel.status}, target=${vessel.targetBridge})`);
      return vessel; // Return the vessel (possibly modified copy)
    }).filter(Boolean); // Filter out any null/false values

    this.logger.debug(`üìä [BRIDGE_TEXT_FILTER] Filtered ${filteredVessels.length}/${allVessels.length} vessels for bridge text`);
    return filteredVessels;
  }

  /**
   * Associate vessel with bridge
   * @param {string} mmsi - Vessel MMSI
   * @param {string} bridgeId - Bridge ID
   */
  associateVesselWithBridge(mmsi, bridgeId) {
    if (!this.bridgeVessels.has(bridgeId)) {
      this.bridgeVessels.set(bridgeId, new Set());
    }
    this.bridgeVessels.get(bridgeId).add(mmsi);
  }

  /**
   * Remove vessel from bridge association
   * @param {string} mmsi - Vessel MMSI
   * @param {string} bridgeId - Bridge ID (optional - removes from all if not specified)
   */
  removeVesselFromBridge(mmsi, bridgeId = null) {
    if (bridgeId) {
      const vesselSet = this.bridgeVessels.get(bridgeId);
      if (vesselSet) {
        vesselSet.delete(mmsi);
      }
    } else {
      this._removeFromBridgeAssociations(mmsi);
    }
  }

  /**
   * Schedule cleanup for vessel
   * @param {string} mmsi - Vessel MMSI
   * @param {number} timeout - Timeout in milliseconds
   */
  scheduleCleanup(mmsi, timeout) {
    this._clearCleanupTimer(mmsi);

    const timer = setTimeout(() => {
      this.removeVessel(mmsi, 'timeout');
    }, timeout);

    this.cleanupTimers.set(mmsi, timer);
  }

  /**
   * Clear cleanup timer for vessel
   * @param {string} mmsi - Vessel MMSI
   */
  clearCleanup(mmsi) {
    this._clearCleanupTimer(mmsi);
  }

  /**
   * Clear all cleanup timers (for testing/shutdown)
   */
  clearAllTimers() {
    for (const timer of this.cleanupTimers.values()) {
      clearTimeout(timer);
    }
    this.cleanupTimers.clear();
    
    // ENHANCED: Clear protection timers
    for (const timer of this.protectionTimers.values()) {
      clearTimeout(timer);
    }
    this.protectionTimers.clear();
    this.targetBridgeProtection.clear();
  }

  /**
   * Get vessel count
   * @returns {number} Number of tracked vessels
   */
  getVesselCount() {
    return this.vessels.size;
  }

  /**
   * Determine if vessel should be assigned a target bridge
   * Stricter filtering to prevent anchored boats from getting target bridges
   * @private
   * @param {Object} vessel - Vessel object
   * @returns {boolean} True if vessel should get target bridge
   */
  _shouldAssignTargetBridge(vessel) {
    const speed = Number(vessel.sog); // Ensure numeric comparison

    // BRIDGE TEXT V2.0: Special handling for stationary vessels near target bridges
    // But still prevent obviously anchored boats far from bridges

    // Calculate distance to nearest bridge first
    let nearestDistance = Infinity;
    let nearestBridgeName = null; // Track name directly during calculation

    for (const bridge of Object.values(this.bridgeRegistry.bridges)) {
      const distance = geometry.calculateDistance(
        vessel.lat, vessel.lon,
        bridge.lat, bridge.lon,
      );
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearestBridgeName = bridge.name; // Track name when we find a closer bridge
      }
    }

    // UPDATED SPEED REQUIREMENTS based on proximity to bridges:
    // - Far from bridges (>500m): Must have ‚â•0.7kn (prevent anchored boats far away)
    // - Approaching bridges (300-500m): Must have ‚â•0.5kn (boats slowing down for bridge)
    // - Near bridges (<300m): Must have ‚â•0.3kn (UPDATED: no more 0.0kn allowance - fixes ZENIT problem)

    let minSpeed;
    let context;

    if (nearestDistance > 500) {
      minSpeed = 0.7;
      context = 'far from bridges';
    } else if (nearestDistance > 300) {
      minSpeed = 0.5;
      context = 'approaching bridge';
    } else {
      // BRIDGE TEXT FORMAT V2.0: No speed requirement within 300m of target bridges
      // nearestBridgeName already tracked during distance calculation above
      const isNearTargetBridge = nearestBridgeName
        && (nearestBridgeName === 'Klaffbron' || nearestBridgeName === 'Stridsbergsbron');

      if (isNearTargetBridge) {
        // Near target bridge (<300m): Allow 0.0kn for waiting status
        minSpeed = 0.0;
        context = 'near target bridge (waiting allowed)';
        this.logger.debug(
          `üéØ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Near target bridge ${nearestBridgeName} - allowing 0.0kn for waiting`,
        );
      } else if (vessel.lastPositionChange && (Date.now() - vessel.lastPositionChange) < 60000) {
        // Near intermediate bridge: Require some movement or recent movement
        // Moved within last minute - allow lower speed
        minSpeed = 0.1;
        context = 'near intermediate bridge (recent movement)';
      } else {
        // No recent movement - require higher speed to avoid anchored boats
        minSpeed = 0.3;
        context = 'near intermediate bridge (no recent movement)';
      }
    }

    if (speed < minSpeed) {
      this.logger.debug(
        `üö´ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Too slow for target bridge (${speed}kn < ${minSpeed}kn, ${nearestDistance.toFixed(0)}m ${context}) - likely anchored`,
      );
      return false;
    }

    // COURSE VALIDATION: Course should be defined (but 0¬∞ is valid north heading)
    // Allow undefined COG near bridges if vessel has reasonable speed
    if (!Number.isFinite(vessel.cog) && nearestDistance > 300) {
      this.logger.debug(
        `üö´ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Invalid/missing course (${vessel.cog}) and far from bridges (${nearestDistance.toFixed(0)}m) - likely stationary/anchored`,
      );
      return false;
    } if (!Number.isFinite(vessel.cog) && nearestDistance <= 300 && speed >= minSpeed) {
      this.logger.debug(
        `‚ö†Ô∏è [TARGET_ASSIGNMENT] ${vessel.mmsi}: No course but near bridge with movement (${nearestDistance.toFixed(0)}m, ${speed}kn) - allowing`,
      );
    }

    this.logger.debug(
      `‚úÖ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Qualifies for target bridge (${speed}kn, ${nearestDistance.toFixed(0)}m, ${vessel.cog}¬∞)`,
    );
    return true;
  }

  /**
   * Check if vessel is suitable for bridge text (consistent with target bridge assignment)
   * @private
   * @param {Object} vessel - Vessel object
   * @returns {boolean} True if vessel should appear in bridge text
   */
  _isVesselSuitableForBridgeText(vessel) {
    // CRITICAL FIX: Under-bridge vessels without targetBridge should always pass
    // They lost their targetBridge after passing final target but are still under a bridge
    if (vessel.status === 'under-bridge' && !vessel.targetBridge) {
      this.logger.debug(
        `‚úÖ [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Under-bridge vessel without targetBridge - allowing for bridge text`,
      );
      return true;
    }

    // CRITICAL FIX: Waiting vessels should be included ONLY if they have a valid target bridge
    // This prevents zombie vessels without target bridge from appearing in bridge text
    if (vessel.status === 'waiting' || vessel.status === 'stallbacka-waiting') {
      if (!vessel.targetBridge) {
        this.logger.debug(
          `‚ùå [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Waiting vessel without targetBridge - excluding from bridge text`,
        );
        return false; // EXCLUDE vessels without target bridge
      }

      this.logger.debug(
        `‚úÖ [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Waiting vessel (${vessel.status}) with target ${vessel.targetBridge} - include in bridge text`,
      );
      return true;
    }

    // If vessel doesn't have target bridge, it was already filtered out in target assignment
    // So vessels with target bridge are presumed suitable. But apply similar dynamic logic.

    const speed = Number(vessel.sog); // Ensure numeric comparison

    // Calculate distance to nearest bridge (same logic as target assignment)
    let nearestDistance = Infinity;
    for (const bridge of Object.values(this.bridgeRegistry.bridges)) {
      const distance = geometry.calculateDistance(
        vessel.lat, vessel.lon,
        bridge.lat, bridge.lon,
      );
      if (distance < nearestDistance) {
        nearestDistance = distance;
      }
    }

    // SAME DYNAMIC LOGIC as target assignment:
    // - Far from bridges (>500m): Must have ‚â•0.5kn (slightly more lenient than target assignment)
    // - Approaching bridges (300-500m): Must have ‚â•0.3kn
    // - Near bridges (<300m): Can be 0.0kn (boats waiting for bridge opening)

    let minSpeed;
    let context;

    if (nearestDistance > 500) {
      minSpeed = 0.5; // Slightly more lenient than target assignment (0.5 vs 0.7)
      context = 'far from bridges';
    } else if (nearestDistance > 300) {
      minSpeed = 0.3;
      context = 'approaching bridge';
    } else {
      // Near bridges (<300m): Allow any speed including 0.0kn (waiting for bridge opening)
      minSpeed = 0.0;
      context = 'near bridge (may be waiting)';
    }

    if (speed < minSpeed) { // Note: < instead of <= to allow exactly 0.0kn when minSpeed is 0.0
      this.logger.debug(
        `üö´ [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Too slow for bridge text (${speed}kn < ${minSpeed}kn, ${nearestDistance.toFixed(0)}m ${context})`,
      );
      return false;
    }

    // The dynamic speed filtering above handles most cases
    // Additional check: boats with target bridges that are very far from their target
    if (vessel.targetBridge && speed <= 0.6) {
      const targetBridge = this.bridgeRegistry.getBridgeByName(vessel.targetBridge);
      if (targetBridge) {
        const distanceToTarget = geometry.calculateDistance(
          vessel.lat, vessel.lon,
          targetBridge.lat, targetBridge.lon,
        );

        if (distanceToTarget > 1000) { // 1km+ from target bridge
          this.logger.debug(
            `üö´ [BRIDGE_TEXT_FILTER] ${vessel.mmsi}: Too far from target bridge ${vessel.targetBridge} with low speed (${distanceToTarget.toFixed(0)}m, ${speed}kn) - likely anchored`,
          );
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Calculate target bridge based on vessel position and direction (ROBUST V2.0)
   * @private
   */
  _calculateTargetBridge(vessel) {
    const { COG_DIRECTIONS } = constants;

    // Determine vessel direction
    const isNorthbound = vessel.cog >= COG_DIRECTIONS.NORTH_MIN
      || vessel.cog <= COG_DIRECTIONS.NORTH_MAX;

    // Get bridge positions from registry for consistency
    const klaffbron = this.bridgeRegistry.getBridgeByName('Klaffbron');
    const stridsbergsbron = this.bridgeRegistry.getBridgeByName('Stridsbergsbron');

    if (!klaffbron || !stridsbergsbron) {
      this.logger.error('üö® [TARGET_ASSIGNMENT] Critical: Target bridges not found in registry');
      return null;
    }

    const klaffbronLat = klaffbron.lat;
    const stridsbergsbronLat = stridsbergsbron.lat;

    if (isNorthbound) {
      // Check if vessel is leaving canal northbound (north of Stridsbergsbron)
      if (vessel.lat > stridsbergsbronLat) {
        this.logger.debug(
          `üö™ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Norrut, norr om Stridsbergsbron (${vessel.lat} > ${stridsbergsbronLat}) ‚Üí l√§mnar kanalen, ingen m√•lbro`,
        );
        return null; // No target bridge - vessel leaving canal
      }

      // Norrut: Vilken m√•lbro tr√§ffas F√ñRST baserat p√• position?
      if (vessel.lat < klaffbronLat) {
        // S√∂der om Klaffbron ‚Üí Klaffbron √§r f√∂rsta m√•lbro
        this.logger.debug(
          `üéØ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Norrut, s√∂der om Klaffbron (${vessel.lat} < ${klaffbronLat}) ‚Üí Klaffbron f√∂rst`,
        );
        return 'Klaffbron';
      }
      // Between Klaffbron and Stridsbergsbron ‚Üí Stridsbergsbron √§r f√∂rsta (och enda) m√•lbro
      this.logger.debug(
        `üéØ [TARGET_ASSIGNMENT] ${vessel.mmsi}: Norrut, mellan broarna (${vessel.lat} >= ${klaffbronLat}) ‚Üí Stridsbergsbron`,
      );
      return 'Stridsbergsbron';
    }

    // Check if vessel is leaving canal southbound (south of Klaffbron)
    if (vessel.lat < klaffbronLat) {
      this.logger.debug(
        `üö™ [TARGET_ASSIGNMENT] ${vessel.mmsi}: S√∂derut, s√∂der om Klaffbron (${vessel.lat} < ${klaffbronLat}) ‚Üí l√§mnar kanalen, ingen m√•lbro`,
      );
      return null; // No target bridge - vessel leaving canal
    }

    // S√∂derutt: Vilken m√•lbro tr√§ffas F√ñRST baserat p√• position?
    if (vessel.lat > stridsbergsbronLat) {
      // Norr om Stridsbergsbron ‚Üí Stridsbergsbron √§r f√∂rsta m√•lbro
      this.logger.debug(
        `üéØ [TARGET_ASSIGNMENT] ${vessel.mmsi}: S√∂derut, norr om Stridsbergsbron (${vessel.lat} > ${stridsbergsbronLat}) ‚Üí Stridsbergsbron f√∂rst`,
      );
      return 'Stridsbergsbron';
    }
    // Between Stridsbergsbron and Klaffbron ‚Üí Klaffbron √§r f√∂rsta (och enda) m√•lbro
    this.logger.debug(
      `üéØ [TARGET_ASSIGNMENT] ${vessel.mmsi}: S√∂derut, mellan broarna (${vessel.lat} <= ${stridsbergsbronLat}) ‚Üí Klaffbron`,
    );
    return 'Klaffbron';
  }

  /**
   * Handle target bridge transitions and protection (NEW: Robust logic)
   * @private
   */
  _handleTargetBridgeTransition(vessel, oldVessel) {
    // Note: APPROACH_RADIUS not used in this method but kept for potential future use

    // BRIDGE TEXT V2.0: Protect targetBridge during "precis passerat" 60s window
    // BUT ONLY if we haven't gotten a new target bridge since then
    if (vessel.lastPassedBridgeTime
        && (Date.now() - vessel.lastPassedBridgeTime) < 60000
        && vessel.lastPassedBridge === vessel.targetBridge) {
      this.logger.debug(
        `‚è∏Ô∏è [TARGET_PROTECTION] ${vessel.mmsi}: Within 60s "precis passerat" window for SAME bridge - keeping targetBridge`,
      );
      return; // Don't change targetBridge during the 60s window for the SAME bridge
    }

    // FIRST: Check if vessel has passed current target bridge and needs next target bridge
    const hasPassedCurrentTarget = this._hasPassedTargetBridge(
      vessel,
      oldVessel,
    );

    this.logger.debug(
      `üîç [TARGET_DEBUG] ${vessel.mmsi}: hasPassedCurrentTarget=${hasPassedCurrentTarget}, targetBridge=${vessel.targetBridge}`,
    );

    if (hasPassedCurrentTarget) {
      // CRITICAL FIX: Don't change targetBridge if vessel is still very close to current target (‚â§100m)
      // This prevents targetBridge from changing from Klaffbron to Stridsbergsbron while vessel is still under/very close to Klaffbron
      const targetBridge = this.bridgeRegistry.getBridgeByName(vessel.targetBridge);
      if (targetBridge) {
        const distanceToCurrentTarget = geometry.calculateDistance(
          vessel.lat, vessel.lon,
          targetBridge.lat, targetBridge.lon,
        );

        this.logger.debug(
          `üîç [TARGET_DEBUG] ${vessel.mmsi}: Distance to ${vessel.targetBridge}: ${distanceToCurrentTarget.toFixed(0)}m`,
        );

        if (distanceToCurrentTarget <= 200) { // Still very close to current target bridge (increased threshold)
          // CRITICAL FIX: Check if vessel has actually passed the target bridge
          const recentlyPassed = vessel.lastPassedBridge === vessel.targetBridge
                                && vessel.lastPassedBridgeTime
                                && (Date.now() - vessel.lastPassedBridgeTime < 120000); // 2 min grace period

          // FIX: hasPassedCurrentTarget already confirms passage - don't need to re-check _wasCloseToTarget
          // The 200m protection should only apply if we HAVEN'T confirmed passage
          // If hasPassedCurrentTarget is true, we KNOW the vessel has passed
          const confirmedPassage = hasPassedCurrentTarget; // Use the actual passage detection result

          if (!recentlyPassed && !confirmedPassage) {
            // Only block if vessel has NOT actually passed the bridge
            this.logger.debug(
              `üõ°Ô∏è [TARGET_TRANSITION_BLOCKED] ${vessel.mmsi}: Blocking targetBridge change while ${distanceToCurrentTarget.toFixed(0)}m from ${vessel.targetBridge}`,
            );
            return; // Don't change targetBridge yet
          }
          // Allow transition despite close distance - vessel has passed the bridge
          this.logger.debug(
            `‚úÖ [TARGET_TRANSITION_ALLOWED] ${vessel.mmsi}: Allowing transition despite ${distanceToCurrentTarget.toFixed(0)}m distance - vessel has passed ${vessel.targetBridge}`,
          );
        }
      }

      const nextTargetBridge = this._calculateNextTargetBridge(vessel);
      if (nextTargetBridge && nextTargetBridge !== vessel.targetBridge) {
        this.logger.debug(
          `üéØ [TARGET_TRANSITION] ${vessel.mmsi}: Passed ${vessel.targetBridge} ‚Üí ${nextTargetBridge}`,
        );
        vessel.targetBridge = nextTargetBridge;
        // Clear _wasCloseToTarget when getting new target bridge
        vessel._wasCloseToTarget = null;
        // Mark as recently passed for bridge text
        vessel.lastPassedBridgeTime = Date.now();
        vessel.lastPassedBridge = oldVessel.targetBridge;
      } else if (!nextTargetBridge) {
        // No more target bridges in this direction - vessel should be removed after passage timeout
        this.logger.debug(
          `üèÅ [TARGET_END] ${vessel.mmsi}: Passed final target bridge ${vessel.targetBridge} - marking for removal`,
        );
        // CRITICAL FIX: Always remove targetBridge after passing final bridge
        // The vessel has PASSED the bridge and is moving away, so keeping targetBridge
        // causes incorrect "approaching" messages after passage
        vessel.targetBridge = null;
        vessel._wasCloseToTarget = null; // Clear when removing target bridge
        this.logger.debug(`‚úÖ [TARGET_REMOVED] ${vessel.mmsi}: Removed targetBridge after passing final bridge (status: ${vessel.status})`);
        vessel.lastPassedBridgeTime = Date.now();
        vessel.lastPassedBridge = oldVessel.targetBridge;
      }
    } else {
      // Check if vessel passed any intermediate bridge (like Stallbackabron)
      this._handleIntermediateBridgePassage(vessel, oldVessel);
    }
  }

  /**
   * Create vessel object from AIS data
   * @private
   */
  _createVesselObject(mmsi, data, oldVessel) {
    // Calculate position tracking with GPS-jump detection
    const currentPosition = { lat: data.lat, lon: data.lon };
    const previousPosition = oldVessel
      ? { lat: oldVessel.lat, lon: oldVessel.lon }
      : null;

    // Handle GPS-jump detection and position validation
    const positionData = this._handleGPSJumpDetection(
      mmsi,
      currentPosition,
      previousPosition,
      oldVessel,
      data, // Pass current AIS data for COG/SOG analysis
    );
    const validatedPosition = positionData.position;
    const positionChangeTime = positionData.changeTime;

    return {
      mmsi,
      lat: validatedPosition.lat,
      lon: validatedPosition.lon,
      sog: data.sog,
      cog: data.cog,
      dirString: data.dirString || 'unknown',
      timestamp: Date.now(),
      name: data.name || 'Unknown',

      // Status and bridge information
      status: oldVessel?.status || 'en-route',
      targetBridge: oldVessel?.targetBridge || null,
      nearBridge: oldVessel?.nearBridge || null,

      // Movement and tracking
      lastPosition: previousPosition,
      lastPositionChange: positionChangeTime,
      lastActiveTime:
        data.sog > 2.0 ? Date.now() : oldVessel?.lastActiveTime || Date.now(),

      // Speed tracking
      speedHistory: this._updateSpeedHistory(oldVessel?.speedHistory, data.sog),
      maxRecentSpeed: this._calculateMaxRecentSpeed(oldVessel, data.sog),

      // Status flags
      isApproaching: oldVessel?.isApproaching || false,
      isWaiting: oldVessel?.isWaiting || false,

      // Bridge passage tracking
      passedBridges: oldVessel?.passedBridges || [],
      lastPassedBridgeTime: oldVessel?.lastPassedBridgeTime || null,

      // Timing and detection
      etaMinutes: oldVessel?.etaMinutes || null,
      waitSince: oldVessel?.waitSince || null,
      speedBelowThresholdSince: oldVessel?.speedBelowThresholdSince || null,

      // Diagnostic information
      graceMisses: oldVessel?.graceMisses || 0,
      _distanceToNearest: oldVessel?._distanceToNearest || 9999,
      _lastSeen: Date.now(),

      // Additional properties for enhanced tracking
      towards: data.towards || null,
      gracePeriod: false,
      _targetAssignmentAttempts: oldVessel?._targetAssignmentAttempts || 0,
      _wasCloseToTarget: oldVessel?._wasCloseToTarget || null, // CRITICAL: Persist _wasCloseToTarget between updates
      confidence: oldVessel?.confidence || 'medium',
      
      // GPS jump analysis data (NEW)
      _positionAnalysis: positionData.analysis || null,
      _gpsJumpDetected: positionData.jumpDetected || false,
      _positionUncertain: positionData.positionUncertain || false,
    };
  }

  /**
   * Update speed history
   * @private
   */
  _updateSpeedHistory(oldHistory, currentSpeed) {
    const history = oldHistory || [];
    const now = Date.now();

    // Add current speed with timestamp
    history.push({ speed: currentSpeed, timestamp: now });

    // Keep only last 10 entries or entries from last 5 minutes
    const fiveMinutesAgo = now - 5 * 60 * 1000;
    return history
      .filter((entry) => entry.timestamp > fiveMinutesAgo)
      .slice(-10);
  }

  /**
   * Calculate maximum recent speed
   * @private
   */
  _calculateMaxRecentSpeed(oldVessel, currentSpeed) {
    if (!oldVessel) {
      return currentSpeed;
    }

    const recentSpeeds = this._updateSpeedHistory(
      oldVessel.speedHistory,
      currentSpeed,
    );
    return Math.max(...recentSpeeds.map((entry) => entry.speed));
  }

  /**
   * Clear cleanup timer
   * @private
   */
  _clearCleanupTimer(mmsi) {
    const timer = this.cleanupTimers.get(mmsi);
    if (timer) {
      clearTimeout(timer);
      this.cleanupTimers.delete(mmsi);
    }
  }

  /**
   * Check if vessel has passed its current target bridge (NEW)
   * @private
   */
  _hasPassedTargetBridge(vessel, oldVessel) {
    if (!vessel.targetBridge || !oldVessel) {
      return false;
    }

    const targetBridge = this.bridgeRegistry.getBridgeByName(
      vessel.targetBridge,
    );
    if (!targetBridge) {
      return false;
    }

    // Calculate distances to target bridge
    const currentDistance = geometry.calculateDistance(
      vessel.lat,
      vessel.lon,
      targetBridge.lat,
      targetBridge.lon,
    );
    const previousDistance = geometry.calculateDistance(
      oldVessel.lat,
      oldVessel.lon,
      targetBridge.lat,
      targetBridge.lon,
    );

    // CRITICAL FIX: Track if vessel has EVER been very close to the target bridge
    // Store in vessel object to persist between updates
    // Check both previous and current distances to catch close approaches
    // IMPORTANT: Check if vessel was close to THIS SPECIFIC target bridge, not just any bridge

    if ((previousDistance <= 100 || currentDistance <= 100)
        && (!oldVessel._wasCloseToTarget || oldVessel._wasCloseToTarget !== vessel.targetBridge)) {
      vessel._wasCloseToTarget = vessel.targetBridge; // Remember which bridge we were close to
      const closeDistance = Math.min(previousDistance, currentDistance);
      this.logger.debug(
        `üéØ [CLOSE_TO_TARGET] ${vessel.mmsi}: Marking as close to ${vessel.targetBridge} (${closeDistance.toFixed(0)}m)`,
      );
    }

    // Check if vessel was EVER close to THIS target bridge (not just in previous update)
    const wasVeryClose = vessel._wasCloseToTarget === vessel.targetBridge;
    const nowMovingAway = currentDistance > previousDistance; // Now getting farther
    const hasMovedAwayEnough = currentDistance > 60; // Has moved away from immediate bridge area

    const hasPassed = wasVeryClose && nowMovingAway && hasMovedAwayEnough;

    // DEBUG: Always log the passage detection logic
    this.logger.debug(
      `üîç [PASSAGE_DEBUG] ${vessel.mmsi} -> ${vessel.targetBridge}: `
      + `prev=${previousDistance.toFixed(0)}m, curr=${currentDistance.toFixed(0)}m, `
      + `wasVeryClose=${wasVeryClose}, nowMovingAway=${nowMovingAway}, hasMovedAwayEnough=${hasMovedAwayEnough}, `
      + `hasPassed=${hasPassed}`,
    );

    if (hasPassed) {
      this.logger.debug(
        `üö¢üí® [PASSAGE_DETECTED] ${vessel.mmsi}: Passed ${
          vessel.targetBridge
        } (${previousDistance.toFixed(0)}m ‚Üí ${currentDistance.toFixed(0)}m)`,
      );
      // CRITICAL: Do NOT clear _wasCloseToTarget here - it needs to persist for 200m protection logic
      // It will be cleared when vessel gets a new target bridge
    }

    return hasPassed;
  }

  /**
   * Calculate next target bridge based on vessel direction (NEW)
   * @private
   */
  _calculateNextTargetBridge(vessel) {
    const { COG_DIRECTIONS } = constants;

    const isNorthbound = vessel.cog >= COG_DIRECTIONS.NORTH_MIN
      || vessel.cog <= COG_DIRECTIONS.NORTH_MAX;
    const currentTarget = vessel.targetBridge;

    if (isNorthbound) {
      // Norrut: Klaffbron ‚Üí Stridsbergsbron ‚Üí null
      if (currentTarget === 'Klaffbron') {
        return 'Stridsbergsbron';
      }
      // Stridsbergsbron is final target bridge northbound
      return null;
    }
    // S√∂derut: Stridsbergsbron ‚Üí Klaffbron ‚Üí null
    if (currentTarget === 'Stridsbergsbron') {
      return 'Klaffbron';
    }
    // Klaffbron is final target bridge southbound
    return null;
  }

  /**
   * Handle GPS-jump detection and position validation (ENHANCED: Direction change aware)
   * @private
   */
  _handleGPSJumpDetection(mmsi, currentPosition, previousPosition, oldVessel, currentAISData) {
    const { MOVEMENT_DETECTION } = constants;

    // TESTING: Skip GPS jump detection for test vessels (allows testing real bridge logic)
    if (mmsi && mmsi.includes('265CONTROL')) {
      this.logger.debug(
        `üß™ [TEST_MODE] Skipping GPS jump detection for test vessel ${mmsi}`,
      );
      return {
        position: currentPosition,
        changeTime: Date.now(),
        jumpDetected: false,
      };
    }

    // For new vessels, no previous position to compare
    if (!oldVessel || !previousPosition) {
      return {
        position: currentPosition,
        changeTime: Date.now(),
        jumpDetected: false,
      };
    }

    // Calculate movement distance
    const movementDistance = geometry.calculateDistance(
      previousPosition.lat,
      previousPosition.lon,
      currentPosition.lat,
      currentPosition.lon,
    );

    // Detect GPS jumps based on movement threshold
    if (movementDistance > MOVEMENT_DETECTION.GPS_JUMP_THRESHOLD) {
      // GPS JUMP DETECTED - LOG ONLY, DO NOT RESTORE POSITION
      this.logger.error(
        `üö® [GPS_JUMP] ${mmsi}: Large movement detected ${movementDistance.toFixed(
          0,
        )}m (threshold: ${MOVEMENT_DETECTION.GPS_JUMP_THRESHOLD}m) - ACCEPTING NEW POSITION`,
      );

      // Per user requirement: Only log GPS jumps, don't restore old position
      // This allows legitimate large movements to be tracked
      return {
        position: currentPosition, // USE NEW POSITION (not old)
        changeTime: Date.now(),
        jumpDetected: true, // Mark as detected for logging
        jumpDistance: movementDistance,
      };
    }

    if (
      movementDistance > 100
      && movementDistance <= MOVEMENT_DETECTION.GPS_JUMP_THRESHOLD
    ) {
      // Medium jump (100-500m): Accept with warning
      this.logger.error(
        `‚ö†Ô∏è [GPS_UNCERTAIN] ${mmsi}: Uncertain position jump ${movementDistance.toFixed(
          0,
        )}m - accepting with caution`,
      );

      return {
        position: currentPosition, // Accept new position
        changeTime: Date.now(),
        jumpDetected: false,
        positionUncertain: true,
      };
    }

    // Normal movement or small jump - determine position change time
    let positionChangeTime = Date.now();
    if (movementDistance <= MOVEMENT_DETECTION.MINIMUM_MOVEMENT) {
      // Very small movement - don't update change time
      positionChangeTime = oldVessel.lastPositionChange || Date.now();
    }

    this.logger.debug(
      `üìç [POSITION_TRACKING] ${mmsi}: movement ${movementDistance.toFixed(
        1,
      )}m, `
        + `updating change time: ${
          movementDistance > MOVEMENT_DETECTION.MINIMUM_MOVEMENT ? 'YES' : 'NO'
        }`,
    );

    return {
      position: currentPosition,
      changeTime: positionChangeTime,
      jumpDetected: false,
    };
  }

  /**
   * Handle passage of intermediate bridges (non-target bridges)
   * @private
   */
  _handleIntermediateBridgePassage(vessel, oldVessel) {
    if (!oldVessel) return;

    // Check all bridges to see if vessel passed any intermediate bridge
    const allBridgeIds = this.bridgeRegistry.getAllBridgeIds();
    const allBridges = allBridgeIds.map((id) => {
      const bridge = this.bridgeRegistry.getBridge(id);
      return {
        id,
        name: bridge.name,
        ...bridge,
      };
    });

    for (const bridge of allBridges) {
      // Skip if this is the target bridge (already handled above)
      if (bridge.name === vessel.targetBridge) continue;

      const hasPassedThisBridge = this._hasPassedBridge(
        vessel,
        oldVessel,
        bridge,
      );
      if (hasPassedThisBridge) {
        this.logger.debug(
          `üåâ [INTERMEDIATE_PASSED] ${vessel.mmsi}: Passed intermediate bridge ${bridge.name}`,
        );

        // Only set lastPassedBridge if no recent target bridge passage
        // This preserves "precis passerat [m√•lbro]" messages from being overwritten
        const timeSinceLastPassed = vessel.lastPassedBridgeTime ? Date.now() - vessel.lastPassedBridgeTime : Infinity;
        const isLastPassedTargetBridge = vessel.lastPassedBridge === 'Klaffbron' || vessel.lastPassedBridge === 'Stridsbergsbron';

        if (!isLastPassedTargetBridge || timeSinceLastPassed > 60000) { // 1 minute grace period
          vessel.lastPassedBridgeTime = Date.now();
          vessel.lastPassedBridge = bridge.name;
          this.logger.debug(
            `üåâ [INTERMEDIATE_OVERWRITE] ${vessel.mmsi}: Set lastPassedBridge to ${bridge.name} (grace period: ${(timeSinceLastPassed / 1000).toFixed(1)}s)`,
          );
        } else {
          this.logger.debug(
            `üõ°Ô∏è [TARGET_PROTECTED] ${vessel.mmsi}: Keeping lastPassedBridge as ${vessel.lastPassedBridge} (target bridge protection, ${(timeSinceLastPassed / 1000).toFixed(1)}s ago)`,
          );
        }

        // Add to passed bridges list if not already there
        if (!vessel.passedBridges) vessel.passedBridges = [];
        if (!vessel.passedBridges.includes(bridge.name)) {
          vessel.passedBridges.push(bridge.name);
        }
        break; // Only handle one bridge passage per update
      }
    }
  }

  /**
   * Check if vessel has passed a specific bridge
   * @private
   */
  _hasPassedBridge(vessel, oldVessel, bridge) {
    // Calculate distances to the bridge
    const currentDistance = geometry.calculateDistance(
      vessel.lat,
      vessel.lon,
      bridge.lat,
      bridge.lon,
    );
    const previousDistance = geometry.calculateDistance(
      oldVessel.lat,
      oldVessel.lon,
      bridge.lat,
      bridge.lon,
    );

    // METHOD 1: Traditional detection - vessel was very close and is now moving away
    const wasVeryClose = previousDistance <= 50; // Was under or very close to bridge
    const isNowFarther = currentDistance > previousDistance; // Now moving away
    const isNowReasonablyFar = currentDistance > 60; // Now clearly past the bridge

    const hasPassedTraditional = wasVeryClose && isNowFarther && isNowReasonablyFar;

    // METHOD 2: Line crossing detection for sparse AIS data
    // Check if vessel crossed the bridge line between previous and current position
    const prevPos = { lat: oldVessel.lat, lon: oldVessel.lon };
    const currPos = { lat: vessel.lat, lon: vessel.lon };

    let hasPassedByCrossing = geometry.hasCrossedBridgeLine(prevPos, currPos, bridge, {
      minProximityM: LINE_CROSSING_MIN_PROXIMITY_M,
    });

    // Additional safety checks for line crossing
    if (hasPassedByCrossing) {
      // Ensure vessel is moving away from bridge after crossing
      const isMovingAway = currentDistance > previousDistance && currentDistance > 60;
      if (!isMovingAway) {
        hasPassedByCrossing = false; // Reject crossing if not moving away
      } else {
        this.logger.debug(
          `üîÄ [LINE_CROSS] ${vessel.mmsi}: Crossed ${bridge.name} line `
          + `(prevDist: ${previousDistance.toFixed(0)}m, currDist: ${currentDistance.toFixed(0)}m)`,
        );
      }
    }

    const hasPassed = hasPassedTraditional || hasPassedByCrossing;

    if (hasPassed && !hasPassedByCrossing) {
      this.logger.debug(
        `üö¢üí® [BRIDGE_PASSAGE] ${vessel.mmsi}: Passed ${
          bridge.name
        } (${previousDistance.toFixed(0)}m ‚Üí ${currentDistance.toFixed(0)}m)`,
      );
    }

    return hasPassed;
  }

  /**
   * Remove vessel from all bridge associations
   * @private
   */
  _removeFromBridgeAssociations(mmsi) {
    for (const vesselSet of this.bridgeVessels.values()) {
      vesselSet.delete(mmsi);
    }
  }
}

module.exports = VesselDataService;
